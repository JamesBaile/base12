#!/usr/bin/env bash

VERSION="0.1.0"
CONFIG=./deploy.conf
LOG=/tmp/provision.log
KEYS=./provisioning/keys
SCRIPTS=./provisioning
TEST=1
REF=
ENV=

#
# Output usage information.
#

usage() {
  cat <<-EOF

  Usage: provision [options] <user> <remote> [command]

  Example: provision root staging
           provision john production keys

  <remote> should match a [remote] section in deploy.conf

  Options:

    -C, --chdir <path>    change the working directory to <path>
    -h, --help            output help information
    -v, --version         output version

  Commands:

    all (default)         runs all provisioning scripts
    environment           updates linux, pulls common apt packages
    keys                  adds /keys/* to root and deploy users
    deployer              configures deploy user based on /deployer/*
    node                  installs node (and npm, part of node now)
    mongo                 installs mongodb
    redis                 installs redis
    mysql                 installs mysql

EOF
}

#
# Abort with <msg>
#

abort() {
  echo
  echo "  $@" 1>&2
  echo
  exit 1
}

hr() {
  echo "============================================================="
}

#
# Log <msg>.
#

log() {
  echo ""
  echo "  â—‹ $@"
  echo ""
}

#
# Check if config <section> exists.
#

config_section() {
  grep "^\[$1" $CONFIG &> /dev/null
}

#
# Get config value by <key>.
#

config_get() {
  local key=$1
  test -n "$key" \
    && grep "^\[$ENV" -A 20 $CONFIG \
    | grep "^$key" \
    | head -n 1 \
    | cut -d ' ' -f 2-999
}

#
# Output version.
#

version() {
  echo $VERSION
}

#
# Run the given remote <cmd>.
#

run() {
  local url="`config_get admin`@`config_get host`"
  #login only:
  #expect -c "spawn ssh $url ; expect assword ; send \"$adminpass\n\" ; interact"
  #old:
  #expectprogram="spawn -noecho ssh $url ; log_user 0 ; expect assword ; send \"$adminpass\r\" ; log_user 1 ; send \"$@\r\" ; close"
  #loud:
  expectprogram="set timeout 5 ; spawn ssh $url ; expect assword ; send \"$adminpass\r\" ; sleep 1 ; send \"$@\r\" ; sleep 1 ; send \"exit\r\" ; interact"
  #current:
  #expectprogram="log_user 1 ; set timeout 5 ; spawn -noecho ssh -o \"PubkeyAuthentication no\" $url ; expect assword ; send \"$adminpass\r\" ; sleep 1 ; send \"$@\r\" ; sleep 1 ; send \"exit\r\" ; interact" 
  expect -c "$expectprogram" > $LOG 2>&1
}

#
# Run a script remotely
#

script() {
  local url="`config_get admin`@`config_get host`"
  local shell="ssh $url"
  $shell 'bash -s' < $@
}

template() {
  { echo "cat <<EOFNOREALLY"
   cat "$@"
   echo "EOFNOREALLY"
  } | sh > "/tmp/templated.sh"

  script "/tmp/templated.sh"
  rm /tmp/templated.sh
}

#
# Launch an interactive ssh console session.
#

console() {
  local url="`config_get user`@`config_get host`"
  local key=`config_get key`
  if test -n "$key"; then
    local shell="ssh -i $key $url"
  else
    local shell="ssh $url"
  fi
  echo $shell
  exec $shell
}

#
# Output config or [key].
#

config() {
  if test $# -eq 0; then
    cat $CONFIG
  else
    config_get $1
  fi
}

#
# Execute hook <name> relative to the path configured.
#

hook() {
  test -n "$1" || abort hook name required
  local hook=$1
  local path=`config_get path`
  local cmd=`config_get $hook`
  if test -n "$cmd"; then
    log "executing $hook \`$cmd\`"
    run "cd $path/current; \
      SHARED=\"$path/shared\" \
      $cmd 2>&1 | tee -a $LOG; \
      exit \${PIPESTATUS[0]}"
    test $? -eq 0
  else
    log hook $hook
  fi
}

#
# Provision the environment
#

environment() {
  hr
  log "setting up the environment"
  script "$SCRIPTS/environment.sh"
}

#
# Add users and public keys
#

# TODO: Pipe errors from the server back. Right now I think it will fail silently.
keys() {
  hr
  log "adding admin public keys"
  # copy all the public keys over
  local url="`config_get admin`@`config_get host`"
  export allkeys="`awk 'FNR==1{print ""}1' $KEYS/*.pub`"
  export admin=`config_get admin`
  template "$SCRIPTS/keys.sh"
}

#
# Add deploy user
#

deployer() {
  hr
  log "setting up deployer user `config_get user`@`config_get host`"
  export deployer=`config_get user`
  export allkeys="`awk 'FNR==1{print ""}1' $KEYS/*.pub`"
  export privatekeypath=`config_get private`
  export privatekey=`cat $privatekeypath`
  export environment=`config_get environment`
  export project=`config_get project`
  template "$SCRIPTS/deployer.sh"
}

#
# Install node
#

node() {
  hr
  log "installing node" 
  script "$SCRIPTS/node.sh"
}

#
# Install upstart script
#

upstart() {
  hr
  log "configuring upstart"
  export project=`config_get project`
  template "$SCRIPTS/upstart.sh"
}

#
# Run all provisioning scripts
#

all() {
  keys
  deployer  
  environment
  node
  upstart
  #mongo
  #redis
  #mysql
}

#
# Provision
#

provision() {
  all
}

#
# Require environment arg.
#

require_env() {
  config_section $ENV || abort "[$ENV] config section not defined"
  test -z "$ENV" && abort "<env> required"
}

# parse argv

while test $# -ne 0; do
  arg=$1; shift
  case $arg in
    -h|--help) usage; exit ;;
    -V|--version) version; exit ;;
    -C|--chdir) log cd $1; cd $1; shift ;;
    all) require_env; all; exit ;;
    environment) require_env; environment; exit ;;
    keys) require_env; keys; exit ;;
    node) require_env; node; exit ;;
    mongo) require_env; mongo; exit ;;
    redis) require_env; redis; exit ;;
    mysql) require_env; mysql; exit ;;
    config) config $@; exit ;;
    *)
      if test -z "$ENV"; then
        ENV=$arg;
      else
        REF="$REF $arg";
      fi
      ;;
  esac
done

require_env

# provision
provision